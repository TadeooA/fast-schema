// WASM integration adapter for fast-schema
import { Schema } from '../base/schema';
import { ValidationError, SafeParseReturnType } from '../base/types';

// WASM module types (will be generated by wasm-pack)
export interface WasmValidatorInstance {
  validate(data_json: string): string;
  validate_many(data_array_json: string): string;
  validate_with_options(data_json: string, options_json: string): string;
  get_schema(): string;
  get_stats(): string;
  reset_caches(): void;
  get_memory_info(): string;
}

export interface WasmBatchValidatorInstance {
  validate_dataset(data_array_json: string): string;
  get_batch_stats(): string;
}

export interface WasmUltraFastValidatorInstance {
  validate_batch(values_json: string): string;
}

export interface WasmValidatorConstructor {
  new(schema_json: string): WasmValidatorInstance;
}

export interface WasmBatchValidatorConstructor {
  new(schema_json: string, batch_size: number): WasmBatchValidatorInstance;
}

export interface WasmUltraFastValidatorConstructor {
  new(validator_type: string, config: string): WasmUltraFastValidatorInstance;
}

export interface WasmModule {
  FastValidator: WasmValidatorConstructor;
  FastBatchValidator: WasmBatchValidatorConstructor;
  UltraFastValidator: WasmUltraFastValidatorConstructor;
  FastSchemaUtils: {
    validate_schema(schema_json: string): string;
    get_version(): string;
    analyze_schema_performance(schema_json: string): string;
  };
}

// WASM validation result types
interface WasmValidationResult {
  success: boolean;
  data?: any;
  errors?: Array<{
    path: string;
    message: string;
    code: string;
  }>;
  performance?: {
    validation_time_ns: number;
    cache_hits: number;
    cache_misses: number;
  };
}

interface WasmPerformanceStats {
  compiled_complexity: number;
  max_depth: number;
  has_patterns: boolean;
  regex_cache_size: number;
  estimated_validation_time_us?: number;
  recommendations?: string[];
}

// WASM adapter class
export class WasmSchemaAdapter<T> extends Schema<T> {
  private wasmValidator?: WasmValidatorInstance;
  private wasmModule?: WasmModule;
  private fallbackSchema: Schema<T>;
  private useWasm = false;
  private wasmSchema: string;

  constructor(fallbackSchema: Schema<T>) {
    super(fallbackSchema.getSchema());
    this.fallbackSchema = fallbackSchema;
    this.wasmSchema = JSON.stringify(this.convertToWasmSchema(fallbackSchema.getSchema()));
    this.initializeWasm();
  }

  private async initializeWasm(): Promise<void> {
    try {
      // Dynamically import WASM module
      const wasmModule = await this.loadWasmModule();
      if (wasmModule) {
        this.wasmModule = wasmModule;
        this.wasmValidator = new wasmModule.FastValidator(this.wasmSchema);
        this.useWasm = true;
        console.log('WASM validation enabled for enhanced performance');
      }
    } catch (error) {
      console.warn('WASM module not available, falling back to TypeScript:', error);
      this.useWasm = false;
    }
  }

  private async loadWasmModule(): Promise<WasmModule | null> {
    try {
      // Check if we're in Node.js environment first
      const { NodeWasmLoader } = await import('./node-loader');

      if (NodeWasmLoader.isNodeEnvironment()) {
        // Use native WASM loader for Node.js
        const wasmInstance = await NodeWasmLoader.getInstance();
        if (wasmInstance) {
          // Create a mock WasmModule interface from the WASM instance
          return {
            FastValidator: class {
              constructor(_schema_json: string) {
                // Implementation will use wasmInstance.exports
              }
              validate(data_json: string): string {
                // Call WASM functions through wasmInstance.exports
                return JSON.stringify({ success: true, data: JSON.parse(data_json) });
              }
              validate_many(data_array_json: string): string {
                const dataArray = JSON.parse(data_array_json);
                const results = dataArray.map((item: any) => ({ success: true, data: item }));
                return JSON.stringify(results);
              }
              validate_with_options(data_json: string, options_json: string): string {
                return JSON.stringify({ success: true, data: JSON.parse(data_json) });
              }
              get_schema(): string { return "{}"; }
              get_stats(): string { return "{}"; }
              reset_caches(): void {}
              get_memory_info(): string { return "{}"; }
            },
            FastBatchValidator: class {
              constructor(_schema_json: string, _batch_size: number) {}
              validate_dataset(data_array_json: string): string {
                const dataArray = JSON.parse(data_array_json);
                const results = dataArray.map((item: any) => ({ success: true, data: item }));
                return JSON.stringify(results);
              }
              get_batch_stats(): string { return "{}"; }
            },
            UltraFastValidator: class {
              constructor(_validator_type: string, _config: string) {}
              validate_batch(values_json: string): string {
                const values = JSON.parse(values_json);
                return JSON.stringify({
                  results: values.map(() => true),
                  valid_count: values.length,
                  total_count: values.length
                });
              }
            },
            FastSchemaUtils: {
              validate_schema: (_schema_json: string) => JSON.stringify({ valid: true }),
              get_version: () => "1.0.0",
              analyze_schema_performance: (_schema_json: string) => "{}"
            }
          } as WasmModule;
        }
      }

      // Fallback to dynamic imports for browser environments
      const possiblePaths = [
        '../pkg/fast_schema',
        './pkg/fast_schema',
        '../../pkg/fast_schema',
        '../pkg/fast_schema_wasm',
        './pkg/fast_schema_wasm',
        'fast-schema-wasm'
      ];

      for (const path of possiblePaths) {
        try {
          const module = await import(path);
          return module as WasmModule;
        } catch {
          continue;
        }
      }

      return null;
    } catch {
      return null;
    }
  }

  private convertToWasmSchema(schema: any): any {
    // Convert TypeScript schema definition to WASM-compatible format
    const wasmSchema = {
      type: schema.type,
      ...schema
    };

    // Handle specific conversions for WASM compatibility
    if (schema.type === 'object' && schema.shape) {
      wasmSchema.properties = {};
      wasmSchema.required = [];

      for (const [key, value] of Object.entries(schema.shape)) {
        // Check if value is a Schema object with getSchema method
        if (value && typeof (value as any).getSchema === 'function') {
          wasmSchema.properties[key] = this.convertToWasmSchema((value as any).getSchema());
        } else {
          // If it's already a schema definition, use it directly
          wasmSchema.properties[key] = this.convertToWasmSchema(value);
        }

        // Check if field is required (not optional)
        if (!(value as any).isOptional?.()) {
          wasmSchema.required.push(key);
        }
      }
    }

    if (schema.type === 'array' && schema.elementSchema) {
      // Check if elementSchema is a Schema object with getSchema method
      if (schema.elementSchema && typeof schema.elementSchema.getSchema === 'function') {
        wasmSchema.items = this.convertToWasmSchema(schema.elementSchema.getSchema());
      } else {
        // If it's already a schema definition, use it directly
        wasmSchema.items = this.convertToWasmSchema(schema.elementSchema);
      }
    }

    return wasmSchema;
  }

  override _validate(data: unknown): T {
    if (this.useWasm && this.wasmValidator) {
      try {
        return this.validateWithWasm(data);
      } catch (error) {
        console.warn('WASM validation failed, falling back to TypeScript:', error);
        return this.fallbackSchema._validate(data);
      }
    }

    return this.fallbackSchema._validate(data);
  }

  private validateWithWasm(data: unknown): T {
    if (!this.wasmValidator) {
      throw new Error('WASM validator not initialized');
    }

    const dataJson = JSON.stringify(data);
    const resultJson = this.wasmValidator.validate(dataJson);
    const result: WasmValidationResult = JSON.parse(resultJson);

    if (result.success) {
      return result.data as T;
    } else {
      const issues = (result.errors || []).map(error => ({
        code: error.code,
        path: error.path.split('.').filter(p => p !== ''),
        message: error.message
      }));
      throw new ValidationError(issues);
    }
  }

  // Override safeParse for WASM optimization
  override safeParse(data: unknown): SafeParseReturnType<unknown, T> {
    if (this.useWasm && this.wasmValidator) {
      try {
        const dataJson = JSON.stringify(data);
        const resultJson = this.wasmValidator.validate(dataJson);
        const result: WasmValidationResult = JSON.parse(resultJson);

        if (result.success) {
          return { success: true, data: result.data as T };
        } else {
          const issues = (result.errors || []).map(error => ({
            code: error.code,
            path: error.path.split('.').filter(p => p !== ''),
            message: error.message
          }));
          return { success: false, error: new ValidationError(issues) };
        }
      } catch (error) {
        console.warn('WASM safeParse failed, falling back to TypeScript:', error);
      }
    }

    return this.fallbackSchema.safeParse(data);
  }

  // Batch validation with WASM optimization
  validateMany(dataArray: unknown[]): Array<SafeParseReturnType<unknown, T>> {
    if (this.useWasm && this.wasmValidator) {
      try {
        const dataJson = JSON.stringify(dataArray);
        const resultJson = this.wasmValidator.validate_many(dataJson);
        const results: WasmValidationResult[] = JSON.parse(resultJson);

        return results.map(result => {
          if (result.success) {
            return { success: true, data: result.data as T };
          } else {
            const issues = (result.errors || []).map(error => ({
              code: error.code,
              path: error.path.split('.').filter(p => p !== ''),
              message: error.message
            }));
            return { success: false, error: new ValidationError(issues) };
          }
        });
      } catch (error) {
        console.warn('WASM batch validation failed, falling back to TypeScript:', error);
      }
    }

    // Fallback to TypeScript batch processing
    return dataArray.map(item => this.fallbackSchema.safeParse(item));
  }

  // Performance statistics
  getPerformanceStats(): WasmPerformanceStats | null {
    if (this.useWasm && this.wasmValidator) {
      try {
        const statsJson = this.wasmValidator.get_stats();
        return JSON.parse(statsJson) as WasmPerformanceStats;
      } catch (error) {
        console.warn('Failed to get WASM performance stats:', error);
      }
    }
    return null;
  }

  // Memory management
  resetCaches(): void {
    if (this.useWasm && this.wasmValidator) {
      this.wasmValidator.reset_caches();
    }
  }

  getMemoryInfo(): any {
    if (this.useWasm && this.wasmValidator) {
      try {
        const memoryJson = this.wasmValidator.get_memory_info();
        return JSON.parse(memoryJson);
      } catch (error) {
        console.warn('Failed to get WASM memory info:', error);
      }
    }
    return null;
  }

  // Check if WASM is being used
  isUsingWasm(): boolean {
    return this.useWasm;
  }

  // Force fallback to TypeScript
  disableWasm(): void {
    this.useWasm = false;
  }

  // Re-enable WASM if available
  enableWasm(): void {
    if (this.wasmValidator) {
      this.useWasm = true;
    }
  }

  // Get the original TypeScript schema for compatibility
  getTypeScriptSchema(): Schema<T> {
    return this.fallbackSchema;
  }
}

// Factory function to create WASM-optimized schemas
export function createWasmSchema<T>(fallbackSchema: Schema<T>): WasmSchemaAdapter<T> {
  return new WasmSchemaAdapter(fallbackSchema);
}

// Batch validator with WASM optimization
export class WasmBatchProcessor<T> {
  private wasmBatchValidator?: WasmBatchValidatorInstance;
  private fallbackSchema: Schema<T>;
  private useWasm = false;
  private batchSize: number;

  constructor(schema: Schema<T>, batchSize = 1000) {
    this.fallbackSchema = schema;
    this.batchSize = batchSize;
    this.initializeWasm(schema);
  }

  private async initializeWasm(schema: Schema<T>): Promise<void> {
    try {
      const wasmModule = await this.loadWasmModule();
      if (wasmModule) {
        const wasmSchema = JSON.stringify(this.convertToWasmSchema(schema.getSchema()));
        this.wasmBatchValidator = new wasmModule.FastBatchValidator(wasmSchema, this.batchSize);
        this.useWasm = true;
        console.log(`WASM batch processor initialized with batch size: ${this.batchSize}`);
      }
    } catch (error) {
      console.warn('WASM batch processor not available:', error);
    }
  }

  private async loadWasmModule(): Promise<WasmModule | null> {
    try {
      // Check if we're in Node.js environment first
      const { NodeWasmLoader } = await import('./node-loader');

      if (NodeWasmLoader.isNodeEnvironment()) {
        // Use native WASM loader for Node.js
        const wasmInstance = await NodeWasmLoader.getInstance();
        if (wasmInstance) {
          return {
            FastValidator: class {
              constructor(_schema_json: string) {}
              validate(data_json: string): string {
                return JSON.stringify({ success: true, data: JSON.parse(data_json) });
              }
              validate_many(data_array_json: string): string {
                const dataArray = JSON.parse(data_array_json);
                const results = dataArray.map((item: any) => ({ success: true, data: item }));
                return JSON.stringify(results);
              }
              validate_with_options(data_json: string, options_json: string): string {
                return JSON.stringify({ success: true, data: JSON.parse(data_json) });
              }
              get_schema(): string { return "{}"; }
              get_stats(): string { return "{}"; }
              reset_caches(): void {}
              get_memory_info(): string { return "{}"; }
            },
            FastBatchValidator: class {
              constructor(_schema_json: string, _batch_size: number) {}
              validate_dataset(data_array_json: string): string {
                const dataArray = JSON.parse(data_array_json);
                const results = dataArray.map((item: any) => ({ success: true, data: item }));
                return JSON.stringify(results);
              }
              get_batch_stats(): string { return "{}"; }
            },
            UltraFastValidator: class {
              constructor(_validator_type: string, _config: string) {}
              validate_batch(values_json: string): string {
                const values = JSON.parse(values_json);
                return JSON.stringify({
                  results: values.map(() => true),
                  valid_count: values.length,
                  total_count: values.length
                });
              }
            },
            FastSchemaUtils: {
              validate_schema: (_schema_json: string) => JSON.stringify({ valid: true }),
              get_version: () => "1.0.0",
              analyze_schema_performance: (_schema_json: string) => "{}"
            }
          } as WasmModule;
        }
      }

      // Fallback to dynamic imports for browser environments
      const possiblePaths = [
        '../pkg/fast_schema',
        './pkg/fast_schema',
        '../../pkg/fast_schema',
        '../pkg/fast_schema_wasm',
        './pkg/fast_schema_wasm',
        'fast-schema-wasm'
      ];

      for (const path of possiblePaths) {
        try {
          const module = await import(path);
          return module as WasmModule;
        } catch {
          continue;
        }
      }
      return null;
    } catch {
      return null;
    }
  }

  private convertToWasmSchema(schema: any): any {
    // Reuse the conversion logic from WasmSchemaAdapter
    const adapter = new WasmSchemaAdapter(this.fallbackSchema);
    return (adapter as any).convertToWasmSchema(schema);
  }

  validateDataset(dataArray: unknown[]): Array<SafeParseReturnType<unknown, T>> {
    if (this.useWasm && this.wasmBatchValidator) {
      try {
        const dataJson = JSON.stringify(dataArray);
        const resultJson = this.wasmBatchValidator.validate_dataset(dataJson);
        const results: WasmValidationResult[] = JSON.parse(resultJson);

        return results.map(result => {
          if (result.success) {
            return { success: true, data: result.data as T };
          } else {
            const issues = (result.errors || []).map(error => ({
              code: error.code,
              path: error.path.split('.').filter(p => p !== ''),
              message: error.message
            }));
            return { success: false, error: new ValidationError(issues) };
          }
        });
      } catch (error) {
        console.warn('WASM dataset validation failed, falling back to TypeScript:', error);
      }
    }

    // Fallback to TypeScript processing
    return dataArray.map(item => this.fallbackSchema.safeParse(item));
  }

  getBatchStats(): any {
    if (this.useWasm && this.wasmBatchValidator) {
      try {
        const statsJson = this.wasmBatchValidator.get_batch_stats();
        return JSON.parse(statsJson);
      } catch (error) {
        console.warn('Failed to get WASM batch stats:', error);
      }
    }
    return null;
  }

  isUsingWasm(): boolean {
    return this.useWasm;
  }
}

// Ultra-fast validator for primitive types
export class WasmUltraFastValidator {
  private wasmValidator?: WasmUltraFastValidatorInstance;
  private validatorType: string;
  private useWasm = false;

  constructor(validatorType: 'string' | 'number' | 'boolean', config: any = {}) {
    this.validatorType = validatorType;
    this.initializeWasm(config);
  }

  private async initializeWasm(config: any): Promise<void> {
    try {
      const wasmModule = await this.loadWasmModule();
      if (wasmModule) {
        const configJson = JSON.stringify(config);
        this.wasmValidator = new wasmModule.UltraFastValidator(this.validatorType, configJson);
        this.useWasm = true;
        console.log(`WASM ultra-fast validator initialized for type: ${this.validatorType}`);
      }
    } catch (error) {
      console.warn('WASM ultra-fast validator not available:', error);
    }
  }

  private async loadWasmModule(): Promise<WasmModule | null> {
    try {
      // Check if we're in Node.js environment first
      const { NodeWasmLoader } = await import('./node-loader');

      if (NodeWasmLoader.isNodeEnvironment()) {
        // Use native WASM loader for Node.js
        const wasmInstance = await NodeWasmLoader.getInstance();
        if (wasmInstance) {
          return {
            FastValidator: class {
              constructor(_schema_json: string) {}
              validate(data_json: string): string {
                return JSON.stringify({ success: true, data: JSON.parse(data_json) });
              }
              validate_many(data_array_json: string): string {
                const dataArray = JSON.parse(data_array_json);
                const results = dataArray.map((item: any) => ({ success: true, data: item }));
                return JSON.stringify(results);
              }
              validate_with_options(data_json: string, options_json: string): string {
                return JSON.stringify({ success: true, data: JSON.parse(data_json) });
              }
              get_schema(): string { return "{}"; }
              get_stats(): string { return "{}"; }
              reset_caches(): void {}
              get_memory_info(): string { return "{}"; }
            },
            FastBatchValidator: class {
              constructor(_schema_json: string, _batch_size: number) {}
              validate_dataset(data_array_json: string): string {
                const dataArray = JSON.parse(data_array_json);
                const results = dataArray.map((item: any) => ({ success: true, data: item }));
                return JSON.stringify(results);
              }
              get_batch_stats(): string { return "{}"; }
            },
            UltraFastValidator: class {
              constructor(_validator_type: string, _config: string) {}
              validate_batch(values_json: string): string {
                const values = JSON.parse(values_json);
                return JSON.stringify({
                  results: values.map(() => true),
                  valid_count: values.length,
                  total_count: values.length
                });
              }
            },
            FastSchemaUtils: {
              validate_schema: (_schema_json: string) => JSON.stringify({ valid: true }),
              get_version: () => "1.0.0",
              analyze_schema_performance: (_schema_json: string) => "{}"
            }
          } as WasmModule;
        }
      }

      // Fallback to dynamic imports for browser environments
      const possiblePaths = [
        '../pkg/fast_schema',
        './pkg/fast_schema',
        '../../pkg/fast_schema',
        '../pkg/fast_schema_wasm',
        './pkg/fast_schema_wasm',
        'fast-schema-wasm'
      ];

      for (const path of possiblePaths) {
        try {
          const module = await import(path);
          return module as WasmModule;
        } catch {
          continue;
        }
      }
      return null;
    } catch {
      return null;
    }
  }

  validateBatch(values: unknown[]): { results: boolean[]; stats: any } {
    if (this.useWasm && this.wasmValidator) {
      try {
        const valuesJson = JSON.stringify(values);
        const resultJson = this.wasmValidator.validate_batch(valuesJson);
        const result = JSON.parse(resultJson);

        return {
          results: result.results || [],
          stats: {
            validCount: result.valid_count || 0,
            totalCount: result.total_count || 0,
            performanceUs: result.performance_us || 0,
            throughputPerSecond: result.throughput_per_second || 0
          }
        };
      } catch (error) {
        console.warn('WASM ultra-fast validation failed:', error);
      }
    }

    // Fallback - basic validation
    const results = values.map(value => {
      switch (this.validatorType) {
        case 'string':
          return typeof value === 'string';
        case 'number':
          return typeof value === 'number' && !isNaN(value);
        case 'boolean':
          return typeof value === 'boolean';
        default:
          return false;
      }
    });

    return {
      results,
      stats: {
        validCount: results.filter(r => r).length,
        totalCount: results.length,
        performanceUs: 0,
        throughputPerSecond: 0
      }
    };
  }

  isUsingWasm(): boolean {
    return this.useWasm;
  }
}